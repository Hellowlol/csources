/* Generated by Nim Compiler v0.10.3 */
/*   (c) 2015 Andreas Rumpf */
/* The generated code is subject to the original license. */
#define NIM_INTBITS 64
#include "nimbase.h"

#include <string.h>

#include <fcntl.h>

#include <sys/stat.h>

#include <unistd.h>

#include <sys/types.h>

#include <sys/time.h>

#include <sys/mman.h>
typedef struct memfile253208 memfile253208;
typedef struct TNimType TNimType;
typedef struct TNimNode TNimNode;
typedef struct NimStringDesc NimStringDesc;
typedef struct TGenericSeq TGenericSeq;
struct  memfile253208  {
void* Mem;
NI Size;
int Handle;
};
typedef N_NIMCALL_PTR(void, TY3289) (void* p, NI op);
typedef N_NIMCALL_PTR(void*, TY3294) (void* p);
struct  TNimType  {
NI size;
NU8 kind;
NU8 flags;
TNimType* base;
TNimNode* node;
void* finalizer;
TY3289 marker;
TY3294 deepcopy;
};
struct  TNimNode  {
NU8 kind;
NI offset;
TNimType* typ;
NCSTRING name;
NI len;
TNimNode** sons;
};
struct  TGenericSeq  {
NI len;
NI reserved;
};
struct  NimStringDesc  {
  TGenericSeq Sup;
NIM_CHAR data[SEQ_DECL_SIZE];
};
N_NIMCALL(void, raiseoserror_116009)(NI32 errorcode);
N_NIMCALL(NI32, oslasterror_116041)(void);
TNimType NTI253208; /* MemFile */
extern TNimType NTI153; /* pointer */
extern TNimType NTI108; /* int */
extern TNimType NTI5811; /* cint */
extern int mappopulate_107538;

N_NIMCALL(memfile253208, open_253807)(NimStringDesc* filename, NU8 mode, NI mappedsize, NI offset, NI newfilesize) {
	memfile253208 result;
	NIM_BOOL readonly;
	int flags;
	int LOC53;
	NI32 LOC59;
	memset((void*)(&result), 0, sizeof(result));
	readonly = (mode == ((NU8) 0));
	{
		if (!readonly) goto LA3;
		flags = O_RDONLY;
	}
	goto LA1;
	LA3: ;
	{
		flags = O_RDWR;
	}
	LA1: ;
	{
		NI32 permissionsmode;
		if (!!((newfilesize == -1))) goto LA8;
		flags = (NI32)((NI32)(flags | O_CREAT) | O_TRUNC);
		permissionsmode = (NI32)(S_IRUSR | S_IWUSR);
		result.Handle = open(filename->data, flags, permissionsmode);
	}
	goto LA6;
	LA8: ;
	{
		result.Handle = open(filename->data, flags);
	}
	LA6: ;
	{
		NI32 LOC20;
		if (!(result.Handle == ((NI32) -1))) goto LA13;
		result.Mem = NIM_NIL;
		result.Size = 0;
		{
			int LOC19;
			if (!!((result.Handle == ((NI32) 0)))) goto LA17;
			LOC19 = 0;
			LOC19 = close(result.Handle);
		}
		LA17: ;
		LOC20 = 0;
		LOC20 = oslasterror_116041();
		raiseoserror_116009(LOC20);
	}
	LA13: ;
	{
		if (!!((newfilesize == -1))) goto LA23;
		{
			int LOC27;
			NI32 LOC35;
			LOC27 = 0;
			LOC27 = ftruncate(result.Handle, ((off_t) (newfilesize)));
			if (!(LOC27 == ((NI32) -1))) goto LA28;
			result.Mem = NIM_NIL;
			result.Size = 0;
			{
				int LOC34;
				if (!!((result.Handle == ((NI32) 0)))) goto LA32;
				LOC34 = 0;
				LOC34 = close(result.Handle);
			}
			LA32: ;
			LOC35 = 0;
			LOC35 = oslasterror_116041();
			raiseoserror_116009(LOC35);
		}
		LA28: ;
	}
	LA23: ;
	{
		if (!!((mappedsize == -1))) goto LA38;
		result.Size = mappedsize;
	}
	goto LA36;
	LA38: ;
	{
		struct stat stat;
		memset((void*)(&stat), 0, sizeof(stat));
		{
			int LOC43;
			LOC43 = 0;
			LOC43 = fstat(result.Handle, (&stat));
			if (!!((LOC43 == ((NI32) -1)))) goto LA44;
			result.Size = ((NI) (stat.st_size));
		}
		goto LA41;
		LA44: ;
		{
			NI32 LOC52;
			result.Mem = NIM_NIL;
			result.Size = 0;
			{
				int LOC51;
				if (!!((result.Handle == ((NI32) 0)))) goto LA49;
				LOC51 = 0;
				LOC51 = close(result.Handle);
			}
			LA49: ;
			LOC52 = 0;
			LOC52 = oslasterror_116041();
			raiseoserror_116009(LOC52);
		}
		LA41: ;
	}
	LA36: ;
	LOC53 = 0;
	{
		if (!readonly) goto LA56;
		LOC53 = PROT_READ;
	}
	goto LA54;
	LA56: ;
	{
		LOC53 = (NI32)(PROT_READ | PROT_WRITE);
	}
	LA54: ;
	LOC59 = 0;
	{
		if (!readonly) goto LA62;
		LOC59 = (NI32)(MAP_PRIVATE | mappopulate_107538);
	}
	goto LA60;
	LA62: ;
	{
		LOC59 = (NI32)(MAP_SHARED | mappopulate_107538);
	}
	LA60: ;
	result.Mem = mmap(NIM_NIL, result.Size, LOC53, LOC59, result.Handle, ((off_t) (offset)));
	{
		NI32 LOC74;
		if (!(result.Mem == ((void*) (MAP_FAILED)))) goto LA67;
		result.Mem = NIM_NIL;
		result.Size = 0;
		{
			int LOC73;
			if (!!((result.Handle == ((NI32) 0)))) goto LA71;
			LOC73 = 0;
			LOC73 = close(result.Handle);
		}
		LA71: ;
		LOC74 = 0;
		LOC74 = oslasterror_116041();
		raiseoserror_116009(LOC74);
	}
	LA67: ;
	return result;
}

N_NIMCALL(void, close_254249)(memfile253208* f) {
	NIM_BOOL error;
	NI32 lasterr;
	error = NIM_FALSE;
	lasterr = 0;
	{
		int LOC5;
		NIM_BOOL LOC6;
		int LOC7;
		if (!!(((*f).Handle == ((NI32) 0)))) goto LA3;
		LOC5 = 0;
		LOC5 = munmap((*f).Mem, (*f).Size);
		error = !((LOC5 == ((NI32) 0)));
		lasterr = oslasterror_116041();
		LOC6 = 0;
		LOC7 = 0;
		LOC7 = close((*f).Handle);
		LOC6 = !((LOC7 == ((NI32) 0)));
		if (LOC6) goto LA8;
		LOC6 = error;
		LA8: ;
		error = LOC6;
	}
	LA3: ;
	(*f).Size = 0;
	(*f).Mem = NIM_NIL;
	(*f).Handle = ((int) 0);
	{
		if (!error) goto LA11;
		raiseoserror_116009(lasterr);
	}
	LA11: ;
}
NIM_EXTERNC N_NOINLINE(void, stdlib_memfilesInit)(void) {
}

NIM_EXTERNC N_NOINLINE(void, stdlib_memfilesDatInit)(void) {
static TNimNode* TMP830[3];
static TNimNode TMP814[4];
NTI253208.size = sizeof(memfile253208);
NTI253208.kind = 18;
NTI253208.base = 0;
NTI253208.flags = 3;
TMP830[0] = &TMP814[1];
TMP814[1].kind = 1;
TMP814[1].offset = offsetof(memfile253208, Mem);
TMP814[1].typ = (&NTI153);
TMP814[1].name = "mem";
TMP830[1] = &TMP814[2];
TMP814[2].kind = 1;
TMP814[2].offset = offsetof(memfile253208, Size);
TMP814[2].typ = (&NTI108);
TMP814[2].name = "size";
TMP830[2] = &TMP814[3];
TMP814[3].kind = 1;
TMP814[3].offset = offsetof(memfile253208, Handle);
TMP814[3].typ = (&NTI5811);
TMP814[3].name = "handle";
TMP814[0].len = 3; TMP814[0].kind = 2; TMP814[0].sons = &TMP830[0];
NTI253208.node = &TMP814[0];
}

